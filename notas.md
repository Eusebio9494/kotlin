## Main.kt
    OOP consta de cuatro principios principales: encapsulamiento, abstracción, herencia y polimorfismo.
    Las clases se definen con la palabra clave class y contienen propiedades y métodos.
    Las propiedades son similares a las variables, excepto que pueden tener métodos get y set personalizados.
    Un constructor especifica cómo crear instancias de los objetos de una clase.
    Puedes omitir la palabra clave constructor cuando defines un constructor principal.
    La herencia facilita la reutilización de código.
    La relación IS-A se refiere a la herencia.
    La relación HAS-A se refiere a la composición.
    Los modificadores de visibilidad son importantes para lograr el encapsulamiento.
    Kotlin ofrece cuatro modificadores de visibilidad: public, private, protected y internal.
    Un delegado de propiedad te permite reutilizar el código get y set en varias clases.
## Lambda.Kt

    Las funciones en Kotlin son construcciones de primer nivel y se pueden tratar como tipos de datos.
    Las expresiones lambda proporcionan una sintaxis abreviada para escribir funciones.
    Puedes pasar tipos de funciones a otras funciones.
    Puedes mostrar un tipo de función desde otra.
    Una expresión lambda muestra el valor de la última expresión.
    Si se omite una etiqueta de parámetro en una expresión lambda con un solo parámetro, se hace referencia a ella con el identificador it.
    Las expresiones lambda se pueden escribir intercaladas sin un nombre de variable.
    Si el último parámetro de una función es un tipo de función, puedes usar la sintaxis lambda al final para mover la expresión lambda después del último paréntesis cuando llamas a una función.
    Las funciones de orden superior son funciones que toman otras funciones como parámetros o muestran una función.
    La función repeat() es una función de orden superior que funciona de manera similar a un bucle for.

## FillInTheBlankQuestion

    Cuando una clase se define como una clase de datos, se implementan los siguientes métodos:
    equals()
    hashCode() (verás este método cuando trabajes con ciertos tipos de colecciones)
    toString()
    componentN(): component1(), component2(), etc.
    copy()
